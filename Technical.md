## 웹 캐시, 왜 쓰나요?

> 웹 캐시(Cache)는 웹 서비스의 성능을 최적화하기 위해 클라이언트와 서버 간의 요청을 줄이고, 불필요한 리소스 로드를 방지하는 중요한 기술입니다.
>
> 이 섹션에서는 웹 캐시의 기본 개념과 그 필요성에 대해 설명하고, 캐시의 효과를 실제 성능 비교를 통해 검증해 보겠습니다.

<br/>

### 웹 캐시란 무엇인가?

웹 캐시는 **클라이언트(브라우저), 서버, 또는 콘텐츠 전송 네트워크(CDN)와 같은 중간 캐시 계층에 자원을 임시로 저장해 두는 메커니즘**입니다.

쉽게 말해, **이전에 서버에서 요청했던 자원**(HTML, CSS, JavaScript, 이미지 등)**을 기억하고 있다가 같은 자원을 다시 요청할 때 저장된 버전을 제공**합니다.

<br/>

### 왜 웹 캐시가 중요한가?

웹 캐시는 성능과 사용자 경험(UX)을 향상시키기 위해 반드시 필요합니다.

웹 캐시를 사용하면 클라이언트와 서버 간의 요청/응답 사이클을 줄여주어 로딩 시간이 단축되기 때문입니다.

캐시가 적용된 웹서비스에서는 다음과 같은 절차를 통해 서버로의 요청 수가 줄어듭니다.

1. **초기 요청 (Initial Request)**: 사용자가 웹 페이지에 처음 접속할 때, 브라우저는 서버에 필요한 자원들을 요청합니다. 이때 서버는 요청에 응답하고, 브라우저는 받은 자원을 캐시에 저장해 둡니다.

2. **캐시된 자원 확인 (Cache Check)**: 이후 같은 자원을 요청할 때, 브라우저는 먼저 캐시에 해당 자원이 있는지 확인합니다.

3. **캐시 적중 (Cache Hit)**: 캐시에서 요청한 자원을 찾을 수 있다면, 서버에 재요청하지 않고 캐시된 자원을 반환합니다. 이로써 불필요한 네트워크 통신을 방지하고 로딩 속도를 빠르게 할 수 있습니다.

4. **캐시 미스 (Cache Miss)**: 만약 캐시에 자원이 없다면, 브라우저는 서버로 새로운 요청을 보내 자원을 받아오고, 받은 자원을 캐시에 저장해 이후에 사용할 수 있도록 합니다.

예를 들어, 사용자가 웹사이트에 접속하여 이미지를 한 번 로드한 후 다시 같은 페이지에 접속할 때 이미지는 캐시에서 로드되므로 서버에 새로운 요청이 발생하지 않습니다. 이는 페이지 로딩 속도를 대폭 향상시키며 사용자에게 더 빠른 응답을 제공합니다.

이렇게 네트워크 요청 대신 필요한 자원을 캐시에서 바로 불러오면 페이지 로드 성능을 크게 향상시키며 첫 화면이 보여지는 속도인 **LCP**(Largest Contentful Paint)를 개선하여 사용자 이탈률을 낮출 수 있습니다.

또한 같은 자원을 반복적으로 요청하지 않기 때문에 서버에 가해지는 부하가 줄어들어 서비스 운영에도 이점이 있습니다.

#### 성능 비교해보기 - 캐시 사용 전후의 차이

정말 캐시를 사용하면 LCP가 줄어들까요? 그 캐시의 효과를 알아보기 위해, 동일한 페이지를 대상으로 캐시 사용 전후의 성능을 비교해 보았습니다.

아래는 성능 측정을 위해 Lighthouse와 WebPageTest 점수를 비교한 결과입니다.

성능 측정 도구로는 Google PageSpeed Insights와 WebPageTest를 사용하였습니다. 아래는 성능 측정 결과를 요약한 표입니다:

| 캐시 설정                                             | LCP   | FCP   | TTFB  | Speed Index | Total Load Time |
| ----------------------------------------------------- | ----- | ----- | ----- | ----------- | --------------- |
| 캐시 비활성화 (Cache-Control: no-store)               | [n초] | [n초] | [n초] | [n초]       | [n초]           |
| 캐시 활성화 (Cache-Control: public, max-age=31536000) | [n초] | [n초] | [n초] | [n초]       | [n초]           |

<br/>

캐시를 활성화한 후, 모든 지표가 크게 개선된 것을 볼 수 있습니다.

특히 LCP(가장 큰 콘텐츠가 화면에 나타나는 시간)가 [n초]에서 [n초]로, FCP(첫 번째 콘텐츠가 화면에 나타나는 시간)가 [n초]에서 [n초]로 단축되었으며, TTFB(첫 번째 바이트가 전송되기까지 걸리는 시간) 또한 [n초]에서 [n초]로 줄어들었습니다.

<br/>

WebPageTest를 사용한 상세 결과는 아래와 같습니다:

캐시 비활성화 상태 (Cache-Control: no-store):

- Start Render Time: [n초]
- Document Complete: [n초]
- Fully Loaded: [n초]
- Total Requests: [n번]
- Total Bytes: [nMB]

  <br/>

캐시 활성화 상태 (Cache-Control: public, max-age=31536000):

- Start Render Time: [n초]
- Document Complete: [n초]
- Fully Loaded: [n초]
- Total Requests: [n번]
- Total Bytes: [nMB]

위 결과를 종합하여 캐시로 하여금 로딩 속도가 유의미하게 개선됨을 확인할 수 있습니다.

<br/>

## 웹 캐시 관리 전략

웹 캐시를 효과적으로 관리하기 위해서는 다양한 전략을 이해하고, 서비스 특성에 맞는 방법을 적용해야 합니다.

아래에서는 대표적인 캐시 관리 전략을 무효화 계층, 구체적인 방법, 프론트엔드 예시 코드, 그리고 각각의 장단점 및 고려 사항을 중심으로 설명하겠습니다.

### 1. 캐시 무효화 계층

캐시 무효화는 캐시에 저장된 데이터를 더 이상 유효하지 않다고 간주하고, 이를 제거하거나 업데이트하는 작업을 말합니다.

캐시 무효화는 크게 다음 세 가지 계층에서 이루어질 수 있습니다:

- **클라이언트 측 (브라우저 캐시)**: 클라이언트의 브라우저가 관리하는 캐시로, 주로 자바스크립트 파일, CSS 파일, 이미지 등의 정적 자원을 저장합니다.
- **프록시 캐시 (CDN 등)**: 클라이언트와 서버 사이에 위치한 캐시 계층으로, 클라이언트 요청을 대신 받아 캐시된 데이터를 전달하거나, 서버로부터 데이터를 받아 캐시에 저장 후 전달합니다.
- **서버 측 캐시 (애플리케이션 서버 캐시)**: 서버 내부의 캐시 저장소(메모리, Redis 등)에 데이터를 저장하여 데이터베이스 요청을 줄이고 성능을 최적화하는 방식입니다.

<br/>

### 2. 캐시 관리 전략

#### 시간 기반 캐시 무효화 (Time-based Invalidation)

자원에 특정 유효 기간(TTL, Time-To-Live)을 설정하여, 기간이 만료되면 캐시가 자동으로 무효화되도록 하는 전략입니다.

`Cache-Control` 및 `Expires` 헤더를 사용하여 자원의 유효 기간을 정의합니다.

- `Cache-Control` 헤더에 `max-age` 값을 설정하여, **자원이 유효한 시간을 지정**합니다.

<br/>

```jsx
useEffect(() => {
  fetch('https://api.example.com/data', {
    // Cache-Control: max-age=3600 (1시간 동안 캐시를 유지)
    headers: { 'Cache-Control': 'max-age=3600' },
  })
    .then((response) => response.json())
    .then((data) => setData(data));
}, []);
```

<br/>

- 구현이 간단하고, 시간 기반으로 캐시를 관리할 수 있어 효율적입니다.
- 일정한 주기로 업데이트되는 데이터에 적합합니다.
- 고정된 TTL 값으로 인해 자주 변경되는 데이터에 부적합할 수 있습니다.

<br/>

#### 버전 관리 기반 캐시 무효화 (Version-based Invalidation)

자원의 URL이나 파일 이름에 버전을 포함시켜, 자원 업데이트 시 캐시된 데이터를 무효화하고 새로운 버전의 데이터를 캐싱하는 전략입니다. 주로 파일의 해시값을 사용합니다.

- 파일 빌드 시 해시값을 붙여 자원의 이름을 변경합니다. 예를 들어, app.js → app.12345.js.
- 서버 응답 헤더에서 ETag를 활용하여 파일 버전을 관리하고, 버전이 변경될 때 캐시를 무효화합니다.

<br/>

```javascript
module.exports = {
  output: {
    filename: 'bundle.[contenthash].js',
  },
};
```

<br/>

- 자원이 변경될 때마다 캐시를 자동으로 무효화하여 최신 데이터를 보장할 수 있습니다.
- 브라우저가 캐시된 파일을 효율적으로 관리할 수 있습니다.
- 매번 자원 파일의 이름이 변경되므로, 이를 참조하는 HTML 파일의 업데이트가 필요하지만, 번들러를 사용한다면 자동으로 갱신됩니다.

#### 수동 캐시 무효화 (Manual Invalidation)

개발자 또는 관리자에 의해 캐시를 수동으로 무효화하는 전략입니다.

자원의 변경 사항이 있을 때 수동으로 캐시를 비우거나, 서버에 `Cache-Control` 헤더로 `no-cache`, `no-store`를 설정하여 캐시를 사용하지 않도록 합니다.

- 캐시 무효화 시점을 개발자가 직접 관리합니다.

<br/>

자원이 변경된 경우, CDN에서 제공하는 API를 통해 특정 자원의 캐시를 강제로 삭제(Purge)합니다.

<br/>

```javascript
// 예시: Cloudflare API를 통해 특정 URL의 캐시 무효화
fetch('https://api.cloudflare.com/client/v4/zones/your-zone-id/purge_cache', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: 'Bearer your-api-key',
  },
  body: JSON.stringify({ files: ['https://example.com/app.js'] }),
});
```

<br/>

- 캐시 무효화 시점을 정확히 통제할 수 있어, 중요한 데이터 변경 시 유용합니다.
- 캐시가 잘못된 경우 즉시 수정이 가능합니다.
- 자동화되지 않아 관리 비용이 증가할 수 있으며, 수동 무효화 시점이 적절하지 않으면 데이터 불일치가 발생할 수 있습니다.
- 인프라나 API를 통해 캐시 무효화를 해야 하므로 추가적인 작업이 필요합니다.

<br/>

#### 조건부 요청 기반 캐시 무효화 (Conditional Requests)

클라이언트가 서버에 자원이 변경되었는지 확인한 후, 변경되었을 때만 새 데이터를 요청하는 방식입니다.

ETag나 Last-Modified 헤더를 사용하여 자원의 변경 여부를 판단합니다.

- 서버가 응답 시 ETag(파일 버전 정보) 또는 Last-Modified(마지막 수정 시간) 값을 헤더에 포함하여 전달합니다.
- 클라이언트가 다시 요청할 때 해당 값을 If-None-Match 또는 If-Modified-Since 헤더에 포함하여 서버에 전송합니다.
- 서버는 자원이 변경되지 않았을 경우 304 Not Modified 응답을 보내고, 클라이언트는 캐시된 자원을 사용합니다.

<br/>

```javascript
fetch('https://api.example.com/data', {
  headers: { 'If-None-Match': 'W/"12345"' },
})
  .then((response) => {
    if (response.status === 304) {
      // 데이터가 변경되지 않음: 캐시된 데이터 사용
    } else {
      return response.json();
    }
  })
  .then((data) => setData(data));
```

<br/>

- 자원이 변경되지 않은 경우 불필요한 데이터 전송을 막아, 네트워크 비용 절감할 수 있습니다.
- 서버와 클라이언트 간 데이터 동기화가 효율적으로 이루어집니다.
- 서버에서 ETag 또는 Last-Modified를 정확하게 관리해야 하며, 복잡한 구현이 필요합니다.

<br/>

### 3. 장단점 및 고려할 점

캐시 전략의 선택은 **데이터의 변경 빈도**와 **일관성 요구사항**에 따라 달라집니다.

정적 자원(이미지, 스타일시트 등)에는 시간 기반 캐시 무효화가 적합하며, 주기적인 업데이트가 필요한 데이터에는 조건부 요청 기반 캐시가 유리합니다.

자주 변경되는 데이터에는 버전 관리 기반 캐시를 적용하여, 데이터 일관성을 보장하는 것이 중요합니다.

따라서 개발 환경과 배포 전략에 따라 적절한 캐시 전략을 선택해야 합니다.

예를 들어, 배포 시마다 자원이 변경되는 경우, 버전 관리 기반 캐시가 적합하고, 변경 빈도가 낮은 정적 콘텐츠는 시간 기반 캐시를 사용할 수 있습니다.

성능 최적화와 데이터 일관성의 균형을 맞추는 것이 핵심입니다.

캐시를 오래 유지하면 성능은 향상되지만, 데이터 일관성이 낮아질 수 있으므로, 서비스 특성에 맞는 TTL 및 캐시 무효화 전략을 수립해야 합니다.

이러한 캐시 관리 전략들을 이해하고 적절히 적용하면, 성능 최적화와 데이터 일관성 유지라는 두 가지 목표를 동시에 달성할 수 있습니다.

<br/>

## 크루루의 캐시 관리 전략

### 들어가기 전에

크루루 팀은 웹사이트 성능을 최적화하고 사용자 경험을 개선하기 위해 **리소스 유형별로 세분화된 캐싱 정책**을 적용하고 있습니다. 이를 통해 자원의 특성에 따라 최적의 캐싱 전략을 도입하고, 불필요한 네트워크 요청을 줄여 로딩 속도를 향상시키고자 했습니다.

현재 크루루의 프론트엔드 애플리케이션은 AWS S3 Bucket을 Origin으로 사용하며, CloudFront(CDN)가 이를 캐싱하여 사용자에게 리소스를 전달하는 구조로 이루어져 있습니다. 따라서 **브라우저 캐시**와 **CDN 캐시**를 동시에 관리해야 했습니다.

### 리소스 별 캐싱 설정

| 구분          | 브라우저 캐시 | CDN 캐시     | 비고                                                          |
| ------------- | ------------- | ------------ | ------------------------------------------------------------- |
| HTML          | 0             | 1년          | Cache invalidation 활용 여부에 따라 CDN 캐시 기한을 조정 필요 |
| CSS/JS        | 1년           | 1년          | 파일명을 이용한 캐시 버스팅 활용                              |
| Image         | 1년           | 1년          | 파일명을 이용한 캐시 버스팅 활용                              |
| Font          | 1년           | 1년          |                                                               |
| Etc (Default) | 1일           | (기본값 1일) |                                                               |

- **HTML 리소스**: 항상 최신 리소스를 제공하기 위해 브라우저 캐시는 max-age=0으로 설정하고, CDN은 최대 1년 동안 캐싱되도록 설정했습니다. index.html에 변경이 있을 경우 cd 과정에서 CloudFront의 캐시를 무효화 해주는 과정을 거치므로 사용자는 최신 버전의 index.html을 볼 수 있습니다.
- **CSS/JS 및 이미지 리소스**: 파일명에 해시 값을 추가하여 캐시 버스팅을 활용하고, 브라우저와 CDN 캐시 모두 최대 1년 동안 캐시를 유지합니다.
- **폰트 리소스**: 변경 가능성이 희박한 리소스라 1년동안 캐시를 유지하도록 설정했습니다.
- **기타 리소스**: 이미지와 같은 기타 리소스는 기본 캐싱 설정인 1일동안 유지됩니다.

<br/>

### 캐시 정책 적용 방법

위와 같은 캐시 정책을 바탕으로 CloudFront의 Function을 이용해 요청 별로 `Cache-Control`헤더를 동적으로 적용하도록 처리했습니다. 이렇게 하면 다양한 리소스 유형에 유연하게 대응할 수 있습니다.

이러한 결정엔 몇 가지 고려사항도 있습니다.

1. **CloudFront Function의 실행 비용**: CloudFront Function은 호출 건당 비용이 발생하므로, 캐시 설정을 적절하게 유지하여 불필요한 캐시 무효화를 방지하고, 서버 부하를 최소화해야 합니다.

2. **응답 헤더 정책 제한**: 현 프로젝트 환경에서는 CloudFront의 응답 헤더 정책을 여러 개 운영하기 어렵기 때문에, 하나의 Function으로 다양한 리소스에 대한 캐시 정책을 관리하는 것이 중요합니다.

3. **지속적인 모니터링**: 캐시 정책을 적용한 후에도, 캐시 적중률(Cache Hit Ratio) 및 리소스 로딩 시간을 지속적으로 모니터링하여 필요시 정책을 조정하고, 성능을 최적화해야 합니다.

<br/>
